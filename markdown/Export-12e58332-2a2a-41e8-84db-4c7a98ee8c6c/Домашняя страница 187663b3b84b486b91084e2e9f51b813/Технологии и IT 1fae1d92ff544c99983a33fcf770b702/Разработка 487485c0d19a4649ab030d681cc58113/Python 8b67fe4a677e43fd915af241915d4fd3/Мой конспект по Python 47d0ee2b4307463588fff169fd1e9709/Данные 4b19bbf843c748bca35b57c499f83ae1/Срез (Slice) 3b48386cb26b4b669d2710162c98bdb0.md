# Срез (Slice)

Использует: ../%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8%209e3a832939aa4b4fb0f9861c2d66b776/slice()%20d9b06e02ee2540098dd427a7c7645565.md
Используется в: ../%D0%92%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%20403b5a5927a74a47a210a54563fe6664/%D0%9F%D0%BE%D0%BB%D1%83%D1%87%D0%B8%D1%82%D1%8C%20%D1%87%D0%B0%D1%81%D1%82%D1%8C%20%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0%20f6d5b6c778504551a3b472bf3f087eb5.md

[Understanding slicing](https://stackoverflow.com/questions/509211/understanding-slicing)

### Определение

**Срез (Slice)** — извлечение нескольких элементов из массива.
Например, извлечение подстроки из строки.

**Подстрока (substring)** — непустая связная часть строки.
Например, год (2022) из даты (01.12.2022).

### Описание

Подстрокой называется какая-то часть строки. Представим, что у нас есть дата в таком формате: *12-08-2034*. Как извлечь из этой строки подстроку, в которую входит только год?

Если подумать логически, то для извлечения года, нам нужно посчитать индекс символа с которого начинается год и затем извлечь четыре символа. Индексы в строке начинаются с нуля, а значит первый символ года доступен по индексу 6, а последний символ находится по индексу 9. Проверим:

```
value = '12-08-2034'

print(value[6]) # => 2
print(value[9]) # => 4

```

Теперь зная эти индексы, мы можем воспользоваться срезами для получения нужной подстроки:

```
value = '12-08-2034'

year = value[6:10]
print(year) # => 2034

```

Срезы для строк в Python - это механизм, с помощью которого извлекается подстрока по указанным параметрам. В примере выше мы взяли подстроку начиная с 6 индекса по 10 индекс не включая, то есть с 6 по 9 включительно. Формула выглядит так:

```
str[начальный индекс:конечный индекс]

# Пара примеров
value = '01-12-9873'

# Срез строки это всегда строка,
# даже если внутри строки было число.
value[1:2] # '1'
value[3:5] # '12'

```

Срезы очень мощный механизм с большим количеством вариаций, например, если не указать вторую границу, то извлечение произойдет до конца строки, тоже самое с первой границей (началом строки):

```
value = 'Hexlet'
value[3:] # 'let'
value[:3] # 'Hex'

```

Мы можем указать даже отрицательные индексы. В таком случае отсчет идет с обратной стороны:

```
value = 'Hexlet'
# Правая граница отрицательная. Считаем -1 от конца строки
value[3:-1] # 'le'
# Левая граница отрицательная. Считаем -5 от конца строки
value[-5:3] # 'ex'

```

У срезов есть третий необязательный параметр - шаг извлечения. По умолчанию он равен единице, но мы можем его изменить:

```
value = 'Hexlet'
value[1:5:2] # el
# 1:5 это 'exle'
# шаг 2 это каждый второй, то есть 'e' и 'l'

```

Все это можно комбинировать с открытыми границами, то есть без указания начала или конца:

```
value = 'Hexlet'
value[:5:2] # 'Hxe'
value[1::2] # 'elt'

```

Шаг может быть отрицательным, в таком случае он берется с конца. Из этого вытекает самый популярный способ использования шага - переворот строки:

```
value = 'Hexlet'
# Пропускаем обе границы
value[::-1] # 'telxeH'

```

Срезы можно указывать не только через числа, но и с использованием переменных:

```
value = 'Hexlet'
start = 1
end = 5
value[start:end] # 'exle'
```

### Пример синтаксиса